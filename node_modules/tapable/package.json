{
  "_args": [
    [
      {
        "raw": "tapable@^1.0.0",
        "scope": null,
        "escapedName": "tapable",
        "name": "tapable",
        "rawSpec": "^1.0.0",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "/Users/ebui91/Projects/react-without-cra/node_modules/webpack"
    ]
  ],
  "_from": "tapable@>=1.0.0 <2.0.0",
  "_id": "tapable@1.0.0",
  "_inCache": true,
  "_location": "/tapable",
  "_nodeVersion": "8.9.4",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/tapable_1.0.0_1519286232237_0.7789554413074959"
  },
  "_npmUser": {
    "name": "sokra",
    "email": "tobias.koppers@googlemail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "tapable@^1.0.0",
    "scope": null,
    "escapedName": "tapable",
    "name": "tapable",
    "rawSpec": "^1.0.0",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/enhanced-resolve",
    "/webpack"
  ],
  "_resolved": "https://registry.npmjs.org/tapable/-/tapable-1.0.0.tgz",
  "_shasum": "cbb639d9002eed9c6b5975eb20598d7936f1f9f2",
  "_shrinkwrap": null,
  "_spec": "tapable@^1.0.0",
  "_where": "/Users/ebui91/Projects/react-without-cra/node_modules/webpack",
  "author": {
    "name": "Tobias Koppers @sokra"
  },
  "bugs": {
    "url": "https://github.com/webpack/tapable/issues"
  },
  "dependencies": {},
  "description": "Just a little module for plugins.",
  "devDependencies": {
    "babel-core": "^6.26.0",
    "babel-jest": "^21.0.2",
    "babel-polyfill": "^6.26.0",
    "babel-preset-env": "^1.6.0",
    "codecov": "^2.3.0",
    "jest": "^21.0.4"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-dQRhbNQkRnaqauC7WqSJ21EEksgT0fYZX2lqXzGkpo8JNig9zGZTYoMGvyI2nWmXlE2VSVXVDu7wLVGu/mQEsg==",
    "shasum": "cbb639d9002eed9c6b5975eb20598d7936f1f9f2",
    "tarball": "https://registry.npmjs.org/tapable/-/tapable-1.0.0.tgz",
    "fileCount": 33,
    "unpackedSize": 241760
  },
  "engines": {
    "node": ">=6"
  },
  "files": [
    "lib"
  ],
  "gitHead": "f2718e63bfede29cbc81cda3ee79a6933ec5af8d",
  "homepage": "https://github.com/webpack/tapable",
  "jest": {
    "transform": {
      "__tests__[\\\\/].+\\.js$": "babel-jest"
    }
  },
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "sokra",
      "email": "tobias.koppers@googlemail.com"
    }
  ],
  "name": "tapable",
  "optionalDependencies": {},
  "readme": "# Tapable\r\n\r\nThe tapable packages exposes many Hook classes, which can be used to create hooks for plugins.\r\n\r\n``` javascript\r\nconst {\r\n\tSyncHook,\r\n\tSyncBailHook,\r\n\tSyncWaterfallHook,\r\n\tSyncLoopHook,\r\n\tAsyncParallelHook,\r\n\tAsyncParallelBailHook,\r\n\tAsyncSeriesHook,\r\n\tAsyncSeriesBailHook,\r\n\tAsyncSeriesWaterfallHook\r\n } = require(\"tapable\");\r\n```\r\n\r\n## Usage\r\n\r\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\r\n\r\n``` js\r\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\r\n```\r\n\r\nThe best practice is to expose all hooks of a class in a `hooks` property:\r\n\r\n``` js\r\nclass Car {\r\n\tconstructor() {\r\n\t\tthis.hooks = {\r\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\r\n\t\t\tbreak: new SyncHook(),\r\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\r\n\t\t};\r\n\t}\r\n\r\n\t/* ... */\r\n}\r\n```\r\n\r\nOther people can now use these hooks:\r\n\r\n``` js\r\nconst myCar = new Car();\r\n\r\n// Use the tap method to add a consument\r\nmyCar.hooks.break.tap(\"WarningLampPlugin\", () => warningLamp.on());\r\n```\r\n\r\nIt's required to pass a name to identify the plugin/reason.\r\n\r\nYou may receive arguments:\r\n\r\n``` js\r\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\r\n```\r\n\r\nFor sync hooks `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\r\n\r\n``` js\r\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\r\n\t// return a promise\r\n\treturn google.maps.findRoute(source, target).then(route => {\r\n\t\troutesList.add(route);\r\n\t});\r\n});\r\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\r\n\tbing.findRoute(source, target, (err, route) => {\r\n\t\tif(err) return callback(err);\r\n\t\troutesList.add(route);\r\n\t\t// call the callback\r\n\t\tcallback();\r\n\t});\r\n});\r\n\r\n// You can still use sync plugins\r\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\r\n\tconst cachedRoute = cache.get(source, target);\r\n\tif(cachedRoute)\r\n\t\troutesList.add(cachedRoute);\r\n})\r\n```\r\n\r\nThe class declaring these hooks need to call them:\r\n\r\n``` js\r\nclass Car {\r\n\t/* ... */\r\n\r\n\tsetSpeed(newSpeed) {\r\n\t\tthis.hooks.accelerate.call(newSpeed);\r\n\t}\r\n\r\n\tuseNavigationSystemPromise(source, target) {\r\n\t\tconst routesList = new List();\r\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then(() => {\r\n\t\t\treturn routesList.getRoutes();\r\n\t\t});\r\n\t}\r\n\r\n\tuseNavigationSystemAsync(source, target, callback) {\r\n\t\tconst routesList = new List();\r\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\r\n\t\t\tif(err) return callback(err);\r\n\t\t\tcallback(null, routesList.getRoutes());\r\n\t\t});\r\n\t}\r\n}\r\n```\r\n\r\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\r\n* The number of registered plugins (none, one, many)\r\n* The kind of registered plugins (sync, async, promise)\r\n* The used call method (sync, async, promise)\r\n* The number of arguments\r\n* Whether interception is used\r\n\r\nThis ensures fastest possible execution.\r\n\r\n## Interception\r\n\r\nAll Hooks offer an additional interception API:\r\n\r\n``` js\r\nmyCar.hooks.calculateRoutes.intercept({\r\n\tcall: (source, target, routesList) => {\r\n\t\tconsole.log(\"Starting to calculate routes\");\r\n\t},\r\n\ttap: (tapInfo) => {\r\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\r\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\r\n\t\treturn tapInfo; // may return a new tapInfo object\r\n\t}\r\n})\r\n```\r\n\r\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\r\n\r\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\r\n\r\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\r\n\r\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\r\n\r\n\r\n## HookMap\r\n\r\nA HookMap is a helper class for a Map with Hooks\r\n\r\n``` js\r\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\r\n```\r\n\r\n``` js\r\nkeyedHook.tap(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\r\nkeyedHook.tapAsync(\"some-key\", \"MyPlugin\", (arg, callback) => { /* ... */ });\r\nkeyedHook.tapPromise(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\r\n```\r\n\r\n``` js\r\nconst hook = keyedHook.get(\"some-key\");\r\nif(hook !== undefined) {\r\n\thook.callAsync(\"arg\", err => { /* ... */ });\r\n}\r\n```\r\n\r\n## Hook/HookMap interface\r\n\r\nPublic:\r\n\r\n``` ts\r\ninterface Hook {\r\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\r\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\r\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\r\n\tintercept: (interceptor: HookInterceptor) => void\r\n}\r\n\r\ninterface HookInterceptor {\r\n\tcall: (context?, ...args) => void,\r\n\tloop: (context?, ...args) => void,\r\n\ttap: (context?, tap: Tap) => void,\r\n\tregister: (tap: Tap) => Tap,\r\n\tcontext: boolean\r\n}\r\n\r\ninterface HookMap {\r\n\tfor: (key: any) => Hook,\r\n\ttap: (key: any, name: string | Tap, fn: (context?, ...args) => Result) => void,\r\n\ttapAsync: (key: any, name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\r\n\ttapPromise: (key: any, name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\r\n\tintercept: (interceptor: HookMapInterceptor) => void\r\n}\r\n\r\ninterface HookMapInterceptor {\r\n\tfactory: (key: any, hook: Hook) => Hook\r\n}\r\n\r\ninterface Tap {\r\n\tname: string,\r\n\ttype: string\r\n\tfn: Function,\r\n\tstage: number,\r\n\tcontext: boolean\r\n}\r\n```\r\n\r\nProtected (only for the class containing the hook):\r\n\r\n``` ts\r\ninterface Hook {\r\n\tisUsed: () => boolean,\r\n\tcall: (...args) => Result,\r\n\tpromise: (...args) => Promise<Result>,\r\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\r\n}\r\n\r\ninterface HookMap {\r\n\tget: (key: any) => Hook | undefined,\r\n\tfor: (key: any) => Hook\r\n}\r\n```\r\n\r\n## MultiHook\r\n\r\nA helper Hook-like class to redirect taps to multiple other hooks:\r\n\r\n``` js\r\nconst { MultiHook } = require(\"tapable\");\r\n\r\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\r\n```\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/webpack/tapable.git"
  },
  "scripts": {
    "test": "jest",
    "travis": "jest --coverage && codecov"
  },
  "version": "1.0.0"
}
